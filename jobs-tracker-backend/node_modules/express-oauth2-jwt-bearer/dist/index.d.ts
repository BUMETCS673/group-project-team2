/// <reference types="node" />
import { Handler } from 'express';
import { Agent } from 'http';
import { Agent as Agent$1 } from 'https';

interface JWK {
  alg?: string
  crv?: string
  d?: string
  dp?: string
  dq?: string
  e?: string
  ext?: boolean
  k?: string
  key_ops?: string[]
  kid?: string
  kty?: string
  n?: string
  oth?: Array<{
    d?: string
    r?: string
    t?: string
  }>
  p?: string
  q?: string
  qi?: string
  use?: string
  x?: string
  y?: string
  x5c?: string[]
  x5t?: string
  'x5t#S256'?: string
  x5u?: string
  [propName: string]: unknown
}
interface JoseHeaderParameters {
  kid?: string
  x5t?: string
  x5c?: string[]
  x5u?: string
  jku?: string
  jwk?: Pick<JWK, 'kty' | 'crv' | 'x' | 'y' | 'e' | 'n'>
  typ?: string
  cty?: string
}
interface JWSHeaderParameters extends JoseHeaderParameters {
  alg?: string
  b64?: boolean
  crit?: string[]
  [propName: string]: unknown
}
interface JWTPayload {
  iss?: string
  sub?: string
  aud?: string | string[]
  jti?: string
  nbf?: number
  exp?: number
  iat?: number
  [propName: string]: unknown
}

declare type FunctionValidator = (value: unknown, claims: JWTPayload, header: JWSHeaderParameters) => Promise<boolean> | boolean;
declare type Validator = FunctionValidator | string | false | undefined;
interface Validators {
    alg: Validator;
    typ: Validator;
    iss: Validator;
    aud: Validator;
    exp: Validator;
    iat: Validator;
    sub: Validator;
    client_id: Validator;
    jti: Validator;
    [key: string]: Validator;
}

interface JwtVerifierOptions {
    issuerBaseURL?: string;
    audience?: string | string[];
    issuer?: string;
    jwksUri?: string;
    agent?: Agent | Agent$1;
    cooldownDuration?: number;
    timeoutDuration?: number;
    validators?: Partial<Validators>;
    clockTolerance?: number;
    maxTokenAge?: number;
    strict?: boolean;
    secret?: string;
    tokenSigningAlg?: string;
}
interface VerifyJwtResult {
    header: JWSHeaderParameters;
    payload: JWTPayload;
    token: string;
}

declare class UnauthorizedError extends Error {
    status: number;
    statusCode: number;
    headers: {
        'WWW-Authenticate': string;
    };
    constructor(message?: string);
}
declare class InvalidRequestError extends UnauthorizedError {
    code: string;
    status: number;
    statusCode: number;
    constructor(message?: string);
}
declare class InvalidTokenError extends UnauthorizedError {
    code: string;
    status: number;
    statusCode: number;
    constructor(message?: string);
}
declare class InsufficientScopeError extends UnauthorizedError {
    code: string;
    status: number;
    statusCode: number;
    constructor(scopes?: string[], message?: string);
}

declare type JSONPrimitive = string | number | boolean | null;
declare type ClaimChecker = (payload?: JWTPayload) => void;
declare type RequiredScopes<R = ClaimChecker> = (scopes: string | string[]) => R;
declare type ClaimIncludes<R = ClaimChecker> = (claim: string, ...expected: JSONPrimitive[]) => R;
declare type ClaimEquals<R = ClaimChecker> = (claim: string, expected: JSONPrimitive) => R;
declare type ClaimCheck<R = ClaimChecker> = (fn: (payload: JWTPayload) => boolean, errMsg?: string) => R;

declare global {
    namespace Express {
        interface Request {
            auth?: VerifyJwtResult;
        }
    }
}
declare const auth: (opts?: JwtVerifierOptions) => Handler;
declare const claimCheck: ClaimCheck<Handler>;
declare const claimEquals: ClaimEquals<Handler>;
declare const claimIncludes: ClaimIncludes<Handler>;
declare const requiredScopes: RequiredScopes<Handler>;

export { JwtVerifierOptions as AuthOptions, VerifyJwtResult as AuthResult, FunctionValidator, InsufficientScopeError, InvalidRequestError, InvalidTokenError, JSONPrimitive, JWSHeaderParameters as JWTHeader, JWTPayload, UnauthorizedError, Validator, Validators, auth, claimCheck, claimEquals, claimIncludes, requiredScopes };
